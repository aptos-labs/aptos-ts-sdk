import { Deserializer, Serializer } from "../../bcs";
import { AnyPublicKeyVariant, AnySignatureVariant, SigningScheme as AuthenticationKeyScheme } from "../../types";
import { AuthenticationKey } from "../authenticationKey";
import { Ed25519PublicKey, Ed25519Signature } from "./ed25519";
import { AccountPublicKey, PublicKey, VerifySignatureArgs } from "./publicKey";
import { Secp256k1PublicKey, Secp256k1Signature } from "./secp256k1";
import { Signature } from "./signature";

/**
 * Represents any public key supported by Aptos.
 *
 * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports
 * `Legacy` and `Unified` authentication keys.
 *
 * Any unified authentication key is represented in the SDK as `AnyPublicKey`.
 */
export class AnyPublicKey extends AccountPublicKey {
  /**
   * Reference to the inner public key
   */
  public readonly publicKey: PublicKey;

  /**
   * Index of the underlying enum variant
   */
  public readonly variant: AnyPublicKeyVariant;

  // region Constructors

  constructor(publicKey: PublicKey) {
    super();
    this.publicKey = publicKey;
    if (publicKey instanceof Ed25519PublicKey) {
      this.variant = AnyPublicKeyVariant.Ed25519;
    } else if (publicKey instanceof Secp256k1PublicKey) {
      this.variant = AnyPublicKeyVariant.Secp256k1;
    } else {
      throw new Error("Unsupported public key type");
    }
  }

  // endregion

  // region AccountPublicKey

  verifySignature(args: VerifySignatureArgs): boolean {
    const { message, signature } = args;
    if (!(signature instanceof AnySignature)) {
      return false;
    }

    return this.publicKey.verifySignature({
      message,
      signature: signature.signature,
    });
  }

  authKey(): AuthenticationKey {
    return AuthenticationKey.fromSchemeAndBytes({
      scheme: AuthenticationKeyScheme.SingleKey,
      input: this.toUint8Array(),
    });
  }

  toUint8Array() {
    return this.bcsToBytes();
  }

  // endregion

  // region Serializable

  serialize(serializer: Serializer): void {
    serializer.serializeU32AsUleb128(this.variant);
    this.publicKey.serialize(serializer);
  }

  static deserialize(deserializer: Deserializer): AnyPublicKey {
    const variantIndex = deserializer.deserializeUleb128AsU32();
    let publicKey: PublicKey;
    switch (variantIndex) {
      case AnyPublicKeyVariant.Ed25519:
        publicKey = Ed25519PublicKey.deserialize(deserializer);
        break;
      case AnyPublicKeyVariant.Secp256k1:
        publicKey = Secp256k1PublicKey.deserialize(deserializer);
        break;
      default:
        throw new Error(`Unknown variant index for AnyPublicKey: ${variantIndex}`);
    }
    return new AnyPublicKey(publicKey);
  }

  // endregion

  /**
   * @deprecated use `instanceof AnyPublicKey` instead.
   */
  static isPublicKey(publicKey: AccountPublicKey): publicKey is AnyPublicKey {
    return publicKey instanceof AnyPublicKey;
  }

  /**
   * @deprecated use `publicKey instanceof Ed25519PublicKey` instead.
   */
  isEd25519(): boolean {
    return this.publicKey instanceof Ed25519PublicKey;
  }

  /**
   * @deprecated use `publicKey instanceof Secp256k1PublicKey` instead.
   */
  isSecp256k1PublicKey(): boolean {
    return this.publicKey instanceof Secp256k1PublicKey;
  }
}

/**
 * Instance of signature that uses the SingleKey authentication scheme.
 * This signature can only be generated by a `SingleKeySigner`, since it uses the
 * same authentication scheme.
 */
export class AnySignature extends Signature {
  public readonly signature: Signature;

  /**
   * Index of the underlying enum variant
   */
  private readonly variant: AnySignatureVariant;

  // region Constructors

  constructor(signature: Signature) {
    super();
    this.signature = signature;

    if (signature instanceof Ed25519Signature) {
      this.variant = AnySignatureVariant.Ed25519;
    } else if (signature instanceof Secp256k1Signature) {
      this.variant = AnySignatureVariant.Secp256k1;
    } else {
      throw new Error("Unsupported signature type");
    }
  }

  // endregion

  // region AccountSignature

  toUint8Array() {
    return this.bcsToBytes();
  }

  // endregion

  // region Serializable

  serialize(serializer: Serializer): void {
    serializer.serializeU32AsUleb128(this.variant);
    this.signature.serialize(serializer);
  }

  static deserialize(deserializer: Deserializer): AnySignature {
    const variantIndex = deserializer.deserializeUleb128AsU32();
    let signature: Signature;
    switch (variantIndex) {
      case AnySignatureVariant.Ed25519:
        signature = Ed25519Signature.deserialize(deserializer);
        break;
      case AnySignatureVariant.Secp256k1:
        signature = Secp256k1Signature.deserialize(deserializer);
        break;
      default:
        throw new Error(`Unknown variant index for AnySignature: ${variantIndex}`);
    }
    return new AnySignature(signature);
  }

  // endregion
}
