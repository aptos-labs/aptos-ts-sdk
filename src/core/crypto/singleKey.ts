import { Deserializer, Serializer } from "../../bcs";
import {
  AnyPublicKeyVariant,
  AnySignatureVariant,
  SigningScheme as AuthenticationKeyScheme,
  HexInput,
} from "../../types";
import { AuthenticationKey } from "../authenticationKey";
import { Ed25519PrivateKey, Ed25519PublicKey, Ed25519Signature } from "./ed25519";
import { AccountPublicKey, PublicKey } from "./publicKey";
import { Secp256k1PrivateKey, Secp256k1PublicKey, Secp256k1Signature } from "./secp256k1";
import { KeylessSignature } from "./keylessType";
import { Signature } from "./signature";
import { AptosConfig } from "../../api";
import { WebAuthnSignature } from "./secp256r1";

export type PrivateKeyInput = Ed25519PrivateKey | Secp256k1PrivateKey;

/**
 * Represents a signature that utilizes the SingleKey authentication scheme.
 * This class is designed to encapsulate various types of signatures, which can
 * only be generated by a `SingleKeySigner` due to the shared authentication mechanism.
 *
 * @extends Signature
 * @group Implementation
 * @category Serialization
 */
export class AnySignature extends Signature {
  public readonly signature: Signature;

  /**
   * Index of the underlying enum variant
   * @group Implementation
   * @category Serialization
   */
  private readonly variant: AnySignatureVariant;

  // region Constructors

  constructor(signature: Signature) {
    super();
    this.signature = signature;

    if (signature instanceof Ed25519Signature) {
      this.variant = AnySignatureVariant.Ed25519;
    } else if (signature instanceof Secp256k1Signature) {
      this.variant = AnySignatureVariant.Secp256k1;
    } else if (signature instanceof WebAuthnSignature) {
      this.variant = AnySignatureVariant.WebAuthn;
    } else if (signature instanceof KeylessSignature) {
      this.variant = AnySignatureVariant.Keyless;
    } else {
      throw new Error("Unsupported signature type");
    }
  }

  // endregion

  // region AccountSignature

  toUint8Array(): Uint8Array {
    // TODO: keep this warning around for a bit, and eventually change this to return `this.signature.toUint8Array()`.
    // eslint-disable-next-line no-console
    console.warn(
      "[Aptos SDK] Calls to AnySignature.toUint8Array() will soon return the underlying signature bytes. " +
        "Use AnySignature.bcsToBytes() instead.",
    );
    return this.bcsToBytes();
  }

  // endregion

  // region Serializable

  serialize(serializer: Serializer): void {
    serializer.serializeU32AsUleb128(this.variant);
    this.signature.serialize(serializer);
  }

  static deserialize(deserializer: Deserializer): AnySignature {
    const variantIndex = deserializer.deserializeUleb128AsU32();
    let signature: Signature;
    switch (variantIndex) {
      case AnySignatureVariant.Ed25519:
        signature = Ed25519Signature.deserialize(deserializer);
        break;
      case AnySignatureVariant.Secp256k1:
        signature = Secp256k1Signature.deserialize(deserializer);
        break;
      case AnySignatureVariant.WebAuthn:
        signature = WebAuthnSignature.deserialize(deserializer);
        break;
      case AnySignatureVariant.Keyless:
        signature = KeylessSignature.deserialize(deserializer);
        break;
      default:
        throw new Error(`Unknown variant index for AnySignature: ${variantIndex}`);
    }
    return new AnySignature(signature);
  }

  // endregion

  static isInstance(signature: Signature): signature is AnySignature {
    return (
      "signature" in signature &&
      typeof signature.signature === "object" &&
      signature.signature !== null &&
      "toUint8Array" in signature.signature
    );
  }
}
